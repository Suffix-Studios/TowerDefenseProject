-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local getSortedEnumItems = TS.import(script, script.Parent, "constants").getSortedEnumItems
local function addPackedBit(info)
	if (bit32.band(info.flags, 2)) ~= 0 then
		info.containsPacking = true
		if (bit32.band(info.flags, 1)) ~= 0 then
			info.containsUnknownPacking = true
		else
			-- We only keep track of guaranteed packing bits, which we can use for optimization.
			info.minimumPackedBits += 1
		end
	end
end
--[[
	*
	 * This runs an additional pass over the SerializerData to perform calculations not feasible type-wise:
	 * 1. Optimize objects
	 * 2. Calculate union sizes
	 * 3. Calculate packing
	 
]]
local function iterateSerializerData(data, info)
	local flags = info.flags
	local kind = data[1]
	if kind == "object_raw" then
		-- We transform objects as an array of tuples, but this is slow to iterate over.
		-- We flatten the raw generated metadata into a single array, which can be iterated much quicker.
		-- We also create a preallocated object that we can clone as we already know the structure ahead of time.
		local preallocation = {}
		local transformed = {}
		for _, _binding in data[2] do
			local key = _binding[1]
			local meta = _binding[2]
			local _arg1 = iterateSerializerData(meta, info)
			-- ▼ Array.push ▼
			table.insert(transformed, key)
			table.insert(transformed, _arg1)
			-- ▲ Array.push ▲
			preallocation[key] = true
		end
		data = { "object", transformed, preallocation }
	elseif kind == "optional" then
		addPackedBit(info)
		info.flags = bit32.bor(info.flags, 1)
		data = { kind, iterateSerializerData(data[2], info) }
	elseif kind == "array" or kind == "set" then
		info.flags = bit32.bor(info.flags, 1)
		data = { kind, iterateSerializerData(data[2], info) }
	elseif kind == "union" then
		-- Whenever we only have two options, we can use a single bit.
		-- We use a byte size of `-1` to indicate a packable union.
		local isPackable = (bit32.band(info.flags, 2)) ~= 0 and #data[3] == 2
		if isPackable then
			addPackedBit(info)
		end
		info.flags = bit32.bor(info.flags, 1)
		local _exp = data[2]
		local _exp_1 = data[3]
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp_1)
		local _callback = function(_param)
			local key = _param[1]
			local data = _param[2]
			return { key, iterateSerializerData(data, info) }
		end
		for _k, _v in _exp_1 do
			_newValue[_k] = _callback(_v, _k - 1, _exp_1)
		end
		-- ▲ ReadonlyArray.map ▲
		data = { kind, _exp, _newValue, if isPackable then -1 elseif #data[3] <= 256 then 1 else 2 }
	elseif kind == "map" then
		info.flags = bit32.bor(info.flags, 1)
		data = { kind, iterateSerializerData(data[2], info), iterateSerializerData(data[3], info) }
	elseif kind == "tuple" then
		local _exp = data[2]
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		local _callback = function(v)
			return iterateSerializerData(v, info)
		end
		for _k, _v in _exp do
			_newValue[_k] = _callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		local fixedElements = _newValue
		local restElement
		if data[3] ~= nil then
			info.flags = bit32.bor(info.flags, 1)
			restElement = iterateSerializerData(data[3], info)
		end
		data = { kind, fixedElements, restElement }
	elseif kind == "literal" then
		-- Whenever we only have two options, we can use a single bit.
		-- We exclude undefined using `data[2] === 0` as it complicates thing.
		if (bit32.band(info.flags, 2)) ~= 0 and #data[2] == 2 and data[3] == 0 then
			addPackedBit(info)
			-- We use `-1` as the size to signify that this union can be packed,
			-- as it's not a valid value otherwise.
			return { kind, data[2], -1 }
		end
		-- Since `undefined` is not included in the size of `data[1]`,
		-- we add the existing value of `data[3]` (which is 1 if undefined is in the union) to `data[1]`
		-- to determine the final required size.
		-- A size of -1 means this isn't a union.
		data = { kind, data[2], if data[3] == -1 then 0 elseif data[3] + #data[2] <= 256 then 1 else 2 }
	elseif kind == "packed" then
		info.flags = bit32.bor(info.flags, 2)
		data = { kind, iterateSerializerData(data[2], info) }
	elseif kind == "boolean" then
		addPackedBit(info)
	elseif kind == "cframe" then
		addPackedBit(info)
	elseif kind == "enum" then
		-- Calculate the sorted enum items so that we can send a single byte for an enum.
		if info.sortedEnums[data[2]] == nil then
			info.sortedEnums[data[2]] = getSortedEnumItems(Enum[data[2]])
		end
	end
	info.flags = flags
	return data
end
local function getMinimumPackedBytes(info)
	return math.max(0, math.ceil(info.minimumPackedBits / 8) - (if info.containsUnknownPacking then 1 else 0))
end
local function processSerializerData(rawData)
	local processedInfo = {
		data = rawData,
		flags = 0,
		containsPacking = false,
		containsUnknownPacking = false,
		minimumPackedBits = 0,
		minimumPackedBytes = 0,
		sortedEnums = {},
	}
	processedInfo.data = iterateSerializerData(rawData, processedInfo)
	processedInfo.minimumPackedBytes = getMinimumPackedBytes(processedInfo)
	return processedInfo
end
return {
	processSerializerData = processSerializerData,
}
