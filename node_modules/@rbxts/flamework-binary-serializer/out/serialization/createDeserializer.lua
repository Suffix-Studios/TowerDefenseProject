--!native
--!optimize 2
-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local AXIS_ALIGNED_ORIENTATIONS = TS.import(script, script.Parent.Parent, "constants").AXIS_ALIGNED_ORIENTATIONS
local function createDeserializer(info)
	local bits = table.create(math.ceil(info.minimumPackedBits / 8) * 8)
	local bitIndex = 0
	local buf
	local offset
	local blobs
	local blobIndex = 0
	local packing = false
	local deserializeCFrame
	local function deserialize(meta)
		local currentOffset = offset
		local kind = meta[1]
		if kind == "f32" then
			offset += 4
			return buffer.readf32(buf, currentOffset)
		elseif kind == "f64" then
			offset += 8
			return buffer.readf64(buf, currentOffset)
		elseif kind == "u8" then
			offset += 1
			return buffer.readu8(buf, currentOffset)
		elseif kind == "u16" then
			offset += 2
			return buffer.readu16(buf, currentOffset)
		elseif kind == "u32" then
			offset += 4
			return buffer.readu32(buf, currentOffset)
		elseif kind == "i8" then
			offset += 1
			return buffer.readi8(buf, currentOffset)
		elseif kind == "i16" then
			offset += 2
			return buffer.readi16(buf, currentOffset)
		elseif kind == "i32" then
			offset += 4
			return buffer.readi32(buf, currentOffset)
		elseif kind == "boolean" and packing then
			bitIndex += 1
			return bits[bitIndex]
		elseif kind == "boolean" then
			offset += 1
			return buffer.readu8(buf, currentOffset) == 1
		elseif kind == "string" then
			local length = buffer.readu32(buf, currentOffset)
			offset += 4 + length
			return buffer.readstring(buf, currentOffset + 4, length)
		elseif kind == "vector" then
			offset += 12
			return Vector3.new(buffer.readf32(buf, currentOffset), buffer.readf32(buf, currentOffset + 4), buffer.readf32(buf, currentOffset + 8))
		elseif kind == "object" then
			local elements = meta[2]
			local obj = table.clone(meta[3])
			for i = 1, #elements, 2 do
				obj[elements[i]] = deserialize(elements[i + 1])
			end
			return obj
		elseif kind == "array" then
			local deserializer = meta[2]
			local length = buffer.readu32(buf, currentOffset)
			local array = table.create(length)
			offset += 4
			for i = 1, length do
				local _arg0 = deserialize(deserializer)
				table.insert(array, _arg0)
			end
			return array
		elseif kind == "tuple" then
			local elements = meta[2]
			local restDeserializer = meta[3]
			local restLength = 0
			if restDeserializer then
				offset += 4
				restLength = buffer.readu32(buf, currentOffset)
			end
			local tuple = table.create(#elements + restLength)
			for _, element in elements do
				local _arg0 = deserialize(element)
				table.insert(tuple, _arg0)
			end
			if restDeserializer then
				for _ = 1, restLength do
					local _arg0 = deserialize(restDeserializer)
					table.insert(tuple, _arg0)
				end
			end
			return tuple
		elseif kind == "map" then
			local keyDeserializer = meta[2]
			local valueDeserializer = meta[3]
			local length = buffer.readu32(buf, currentOffset)
			local map = {}
			offset += 4
			for i = 1, length do
				local _arg0 = deserialize(keyDeserializer)
				local _arg1 = deserialize(valueDeserializer)
				map[_arg0] = _arg1
			end
			return map
		elseif kind == "set" then
			local valueDeserializer = meta[2]
			local length = buffer.readu32(buf, currentOffset)
			local set = {}
			offset += 4
			for i = 1, length do
				local _arg0 = deserialize(valueDeserializer)
				set[_arg0] = true
			end
			return set
		elseif kind == "optional" and packing then
			bitIndex += 1
			return if bits[bitIndex] then deserialize(meta[2]) else nil
		elseif kind == "optional" then
			offset += 1
			return if buffer.readu8(buf, currentOffset) == 1 then deserialize(meta[2]) else nil
		elseif kind == "union" then
			local byteSize = meta[4]
			local tagIndex
			if byteSize == 1 then
				offset += 1
				tagIndex = buffer.readu8(buf, currentOffset)
			elseif byteSize == 2 then
				offset += 2
				tagIndex = buffer.readu16(buf, currentOffset)
			else
				bitIndex += 1
				tagIndex = if bits[bitIndex] then 0 else 1
			end
			local tag = meta[3][tagIndex + 1]
			local object = deserialize(tag[2])
			object[meta[2]] = tag[1]
			return object
		elseif kind == "literal" then
			local literals = meta[2]
			local byteSize = meta[3]
			if byteSize == 1 then
				offset += 1
				return literals[buffer.readu8(buf, currentOffset) + 1]
			elseif byteSize == 2 then
				offset += 2
				return literals[buffer.readu16(buf, currentOffset) + 1]
			elseif byteSize == -1 then
				bitIndex += 1
				return if bits[bitIndex] then literals[1] else literals[2]
			else
				return literals[1]
			end
		elseif kind == "blob" then
			blobIndex += 1
			return blobs[blobIndex]
		elseif kind == "packed" then
			local innerType = meta[2]
			local wasPacking = packing
			packing = true
			local value = deserialize(innerType)
			packing = wasPacking
			return value
		elseif kind == "enum" then
			local index = buffer.readu8(buf, currentOffset)
			offset += 1
			return info.sortedEnums[meta[2]][index + 1]
		elseif kind == "cframe" and packing then
			bitIndex += 1
			-- This is an unoptimized CFrame.
			if not bits[bitIndex] then
				return deserializeCFrame()
			end
			local packed = buffer.readu8(buf, currentOffset)
			offset += 1
			local optimizedPosition = bit32.band(packed, 0x60)
			local optimizedRotation = bit32.band(packed, 0x1f)
			local position
			if optimizedPosition == 0x20 then
				position = Vector3.zero
			elseif optimizedPosition == 0x60 then
				position = Vector3.one
			else
				position = Vector3.new(buffer.readf32(buf, offset), buffer.readf32(buf, offset + 4), buffer.readf32(buf, offset + 8))
				offset += 12
			end
			if optimizedRotation ~= 0x1f then
				local _exp = AXIS_ALIGNED_ORIENTATIONS[optimizedRotation + 1]
				local _position = position
				return _exp + _position
			else
				local axisRotation = Vector3.new(buffer.readf32(buf, offset), buffer.readf32(buf, offset + 4), buffer.readf32(buf, offset + 8))
				offset += 12
				if axisRotation.Magnitude == 0 then
					return CFrame.new(position)
				end
				local _exp = CFrame.fromAxisAngle(axisRotation.Unit, axisRotation.Magnitude)
				local _position = position
				return _exp + _position
			end
		elseif kind == "cframe" then
			return deserializeCFrame()
		elseif kind == "colorsequence" then
			local keypointCount = buffer.readu8(buf, currentOffset)
			local keypoints = {}
			offset += 1 + keypointCount * 16
			for i = 1, keypointCount do
				local keypointOffset = currentOffset + 1 + 16 * (i - 1)
				local time = buffer.readf32(buf, keypointOffset)
				local value = Color3.new(buffer.readf32(buf, keypointOffset + 4), buffer.readf32(buf, keypointOffset + 8), buffer.readf32(buf, keypointOffset + 12))
				local _colorSequenceKeypoint = ColorSequenceKeypoint.new(time, value)
				table.insert(keypoints, _colorSequenceKeypoint)
			end
			return ColorSequence.new(keypoints)
		elseif kind == "numbersequence" then
			local keypointCount = buffer.readu8(buf, currentOffset)
			local keypoints = {}
			offset += 1 + keypointCount * 8
			for i = 1, keypointCount do
				local keypointOffset = currentOffset + 1 + 8 * (i - 1)
				local time = buffer.readf32(buf, keypointOffset)
				local value = buffer.readf32(buf, keypointOffset + 4)
				local _numberSequenceKeypoint = NumberSequenceKeypoint.new(time, value)
				table.insert(keypoints, _numberSequenceKeypoint)
			end
			return NumberSequence.new(keypoints)
		elseif kind == "color3" then
			offset += 12
			return Color3.new(buffer.readf32(buf, currentOffset), buffer.readf32(buf, currentOffset + 4), buffer.readf32(buf, currentOffset + 8))
		else
			error(`unexpected kind: {kind}`)
		end
	end
	function deserializeCFrame()
		local currentOffset = offset
		offset += 4 * 6
		local position = Vector3.new(buffer.readf32(buf, currentOffset), buffer.readf32(buf, currentOffset + 4), buffer.readf32(buf, currentOffset + 8))
		local rotation = Vector3.new(buffer.readf32(buf, currentOffset + 12), buffer.readf32(buf, currentOffset + 16), buffer.readf32(buf, currentOffset + 20))
		return if rotation.Magnitude == 0 then CFrame.new(position) else CFrame.fromAxisAngle(rotation.Unit, rotation.Magnitude) + position
	end
	local function readBits()
		local guaranteedBytes = info.minimumPackedBytes
		while true do
			local currentByte = buffer.readu8(buf, offset)
			local guaranteedByte = offset < guaranteedBytes
			for bit = if guaranteedByte then 0 else 1, 7 do
				local value = (bit32.rshift(currentByte, bit)) % 2 == 1
				table.insert(bits, value)
			end
			offset += 1
			-- Variable bit indicated the end.
			if not guaranteedByte and currentByte % 2 == 0 then
				break
			end
			-- We only have guaranteed bits and we reached the end.
			if not info.containsUnknownPacking and offset == guaranteedBytes then
				break
			end
		end
	end
	return function(input, inputBlobs)
		blobs = inputBlobs
		buf = input
		offset = 0
		blobIndex = 0
		bitIndex = 0
		if info.containsPacking then
			table.clear(bits)
			readBits()
		end
		return deserialize(info.data)
	end
end
return {
	createDeserializer = createDeserializer,
}
