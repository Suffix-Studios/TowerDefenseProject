--!native
--!optimize 2
-- Compiled with roblox-ts v2.3.0
local TS = _G[script]
local AXIS_ALIGNED_ORIENTATIONS = TS.import(script, script.Parent.Parent, "constants").AXIS_ALIGNED_ORIENTATIONS
local function createSerializer(info)
	local bits = table.create(info.minimumPackedBits)
	local currentSize = 2 ^ 8
	local buf = buffer.create(currentSize)
	local offset
	local blobs
	local packing = false
	local function allocate(size)
		offset += size
		if offset > currentSize then
			local newSize = 2 ^ math.ceil(math.log(offset) / math.log(2))
			local oldBuffer = buf
			currentSize = newSize
			buf = buffer.create(newSize)
			buffer.copy(buf, 0, oldBuffer)
		end
	end
	local function serialize(value, meta)
		local currentOffset = offset
		local kind = meta[1]
		if kind == "f32" then
			allocate(4)
			buffer.writef32(buf, currentOffset, value)
		elseif kind == "f64" then
			allocate(8)
			buffer.writef64(buf, currentOffset, value)
		elseif kind == "u8" then
			allocate(1)
			buffer.writeu8(buf, currentOffset, value)
		elseif kind == "u16" then
			allocate(2)
			buffer.writeu16(buf, currentOffset, value)
		elseif kind == "u32" then
			allocate(4)
			buffer.writeu32(buf, currentOffset, value)
		elseif kind == "i8" then
			allocate(1)
			buffer.writei8(buf, currentOffset, value)
		elseif kind == "i16" then
			allocate(2)
			buffer.writei16(buf, currentOffset, value)
		elseif kind == "i32" then
			allocate(4)
			buffer.writei32(buf, currentOffset, value)
		elseif kind == "boolean" and packing then
			local _value = value
			table.insert(bits, _value)
		elseif kind == "boolean" then
			allocate(1)
			buffer.writeu8(buf, currentOffset, if value == true then 1 else 0)
		elseif kind == "string" then
			local size = #value
			allocate(4 + size)
			buffer.writeu32(buf, currentOffset, size)
			buffer.writestring(buf, currentOffset + 4, value)
		elseif kind == "vector" then
			allocate(12)
			buffer.writef32(buf, currentOffset, value.X)
			buffer.writef32(buf, currentOffset + 4, value.Y)
			buffer.writef32(buf, currentOffset + 8, value.Z)
		elseif kind == "object" then
			local elements = meta[2]
			for i = 1, #elements, 2 do
				serialize(value[elements[i]], elements[i + 1])
			end
		elseif kind == "array" then
			local serializer = meta[2]
			allocate(4)
			buffer.writeu32(buf, currentOffset, #value)
			for _, element in value do
				serialize(element, serializer)
			end
		elseif kind == "tuple" then
			local elements = meta[2]
			local restSerializer = meta[3]
			local size = #value
			-- We serialize the rest element length first so that the deserializer can allocate accordingly.
			if restSerializer then
				allocate(4)
				buffer.writeu32(buf, currentOffset, size - #elements)
			end
			for i = 1, size do
				local serializer = elements[i] or restSerializer
				if serializer then
					serialize(value[i], serializer)
				end
			end
		elseif kind == "map" then
			local keySerializer = meta[2]
			local valueSerializer = meta[3]
			allocate(4)
			local size = 0
			for elementIndex, elementValue in value do
				size += 1
				serialize(elementIndex, keySerializer)
				serialize(elementValue, valueSerializer)
			end
			-- We already allocated this space before serializing the map, so this is safe.
			buffer.writeu32(buf, currentOffset, size)
		elseif kind == "set" then
			-- We could just generate `Map<V, true>` for sets, but this is more efficient as it omits serializing a boolean per value.
			local valueSerializer = meta[2]
			allocate(4)
			local size = 0
			for elementValue in value do
				size += 1
				serialize(elementValue, valueSerializer)
			end
			-- We already allocated this space before serializing the set, so this is safe.
			buffer.writeu32(buf, currentOffset, size)
		elseif kind == "optional" and packing then
			if value ~= nil then
				table.insert(bits, true)
				serialize(value, meta[2])
			else
				table.insert(bits, false)
			end
		elseif kind == "optional" then
			allocate(1)
			if value ~= nil then
				buffer.writeu8(buf, currentOffset, 1)
				serialize(value, meta[2])
			else
				buffer.writeu8(buf, currentOffset, 0)
			end
		elseif kind == "union" then
			local tagName = meta[2]
			local tagged = meta[3]
			local byteSize = meta[4]
			local objectTag = value[tagName]
			local tagIndex = 0
			local tagMetadata
			for i = 1, #tagged do
				local tagObject = tagged[i]
				if tagObject[1] == objectTag then
					tagIndex = i - 1
					tagMetadata = tagObject[2]
					break
				end
			end
			if byteSize == 1 then
				allocate(1)
				buffer.writeu8(buf, currentOffset, tagIndex)
			elseif byteSize == 2 then
				allocate(2)
				buffer.writeu16(buf, currentOffset, tagIndex)
			elseif byteSize == -1 then
				local _arg0 = tagIndex == 0
				table.insert(bits, _arg0)
			end
			serialize(value, tagMetadata)
		elseif kind == "literal" then
			-- We support `undefined` as a literal, but `indexOf` will actually return -1
			-- This is fine, though, as -1 will serialize as the max integer which will be undefined on unions that do not exceed the size limit.
			local literals = meta[2]
			local byteSize = meta[3]
			if byteSize == 1 then
				local _value = value
				local index = (table.find(literals, _value) or 0) - 1
				allocate(1)
				buffer.writeu8(buf, currentOffset, index)
			elseif byteSize == 2 then
				local _value = value
				local index = (table.find(literals, _value) or 0) - 1
				allocate(2)
				buffer.writeu16(buf, currentOffset, index)
			elseif byteSize == -1 then
				local _arg0 = value == literals[1]
				table.insert(bits, _arg0)
			end
		elseif kind == "blob" then
			-- Value will always be defined because if it isn't, it will be wrapped in `optional`
			local _blobs = blobs
			local _value = value
			table.insert(_blobs, _value)
		elseif kind == "packed" then
			local innerType = meta[2]
			local wasPacking = packing
			packing = true
			serialize(value, innerType)
			packing = wasPacking
		elseif kind == "enum" then
			local _exp = info.sortedEnums[meta[2]]
			local _value = value
			local enumIndex = (table.find(_exp, _value) or 0) - 1
			allocate(1)
			buffer.writeu8(buf, currentOffset, enumIndex)
		elseif kind == "cframe" and packing then
			-- 1-5: Orientation, 6-7: Position, 8: unused
			local optimizedPosition = false
			local optimizedRotation = false
			local packed = 0
			local cframe = value
			if cframe.Position == Vector3.zero then
				optimizedPosition = true
				packed += 0x20
			elseif cframe.Position == Vector3.one then
				optimizedPosition = true
				packed += 0x20
				packed += 0x40
			end
			local _rotation = cframe.Rotation
			local specialCase = (table.find(AXIS_ALIGNED_ORIENTATIONS, _rotation) or 0) - 1
			if specialCase ~= -1 then
				optimizedRotation = true
				packed += specialCase
			else
				packed += 0x1f
			end
			local optimized = optimizedPosition or optimizedRotation
			table.insert(bits, optimized)
			allocate((if optimized then 1 else 0) + (if optimizedPosition then 0 else 12) + (if optimizedRotation then 0 else 12))
			local newOffset = currentOffset
			if optimized then
				buffer.writeu8(buf, newOffset, packed)
				newOffset += 1
			end
			if not optimizedPosition then
				buffer.writef32(buf, newOffset, cframe.X)
				buffer.writef32(buf, newOffset + 4, cframe.Y)
				buffer.writef32(buf, newOffset + 8, cframe.Z)
				newOffset += 12
			end
			if not optimizedRotation then
				local axis, angle = cframe:ToAxisAngle()
				buffer.writef32(buf, newOffset, axis.X * angle)
				buffer.writef32(buf, newOffset + 4, axis.Y * angle)
				buffer.writef32(buf, newOffset + 8, axis.Z * angle)
			end
		elseif kind == "cframe" then
			allocate(4 * 6)
			buffer.writef32(buf, currentOffset, value.X)
			buffer.writef32(buf, currentOffset + 4, value.Y)
			buffer.writef32(buf, currentOffset + 8, value.Z)
			local axis, angle = value:ToAxisAngle()
			buffer.writef32(buf, currentOffset + 12, axis.X * angle)
			buffer.writef32(buf, currentOffset + 16, axis.Y * angle)
			buffer.writef32(buf, currentOffset + 20, axis.Z * angle)
		elseif kind == "colorsequence" then
			local keypoints = value.Keypoints
			local keypointCount = #keypoints
			allocate(1 + keypointCount * 16)
			buffer.writeu8(buf, currentOffset, keypointCount)
			for i = 1, keypointCount do
				local keypointOffset = currentOffset + 1 + 16 * (i - 1)
				local keypoint = keypoints[i]
				buffer.writef32(buf, keypointOffset, keypoint.Time)
				buffer.writef32(buf, keypointOffset + 4, keypoint.Value.R)
				buffer.writef32(buf, keypointOffset + 8, keypoint.Value.G)
				buffer.writef32(buf, keypointOffset + 12, keypoint.Value.B)
			end
		elseif kind == "numbersequence" then
			local keypoints = value.Keypoints
			local keypointCount = #keypoints
			allocate(1 + keypointCount * 8)
			buffer.writeu8(buf, currentOffset, keypointCount)
			for i = 1, keypointCount do
				local keypointOffset = currentOffset + 1 + 8 * (i - 1)
				local keypoint = keypoints[i]
				buffer.writef32(buf, keypointOffset, keypoint.Time)
				buffer.writef32(buf, keypointOffset + 4, keypoint.Value)
			end
		elseif kind == "color3" then
			allocate(12)
			buffer.writef32(buf, currentOffset, value.R)
			buffer.writef32(buf, currentOffset + 4, value.G)
			buffer.writef32(buf, currentOffset + 8, value.B)
		else
			error(`unexpected kind: {kind}`)
		end
	end
	local function writeBits(buf, offset, bitOffset, bytes, variable)
		local bitSize = #bits
		for byte = 0, bytes - 1 do
			local currentByte = 0
			for bit = if variable then 1 else 0, math.min(7, bitSize - bitOffset) do
				currentByte += bit32.lshift((if bits[bitOffset + 1] then 1 else 0), bit)
				bitOffset += 1
			end
			if variable and byte ~= bytes - 1 then
				currentByte += 1
			end
			buffer.writeu8(buf, offset, currentByte)
			offset += 1
		end
	end
	local function calculatePackedBytes()
		local minimumBytes = info.minimumPackedBytes
		if info.containsUnknownPacking then
			local variableBytes = math.max(1, math.ceil((#bits - minimumBytes * 8) / 7))
			local totalByteCount = minimumBytes + variableBytes
			return minimumBytes, variableBytes, totalByteCount
		end
		return minimumBytes, 0, minimumBytes
	end
	return function(value)
		offset = 0
		blobs = {}
		table.clear(bits)
		serialize(value, info.data)
		if info.containsPacking then
			local minimumBytes, variableBytes, totalBytes = calculatePackedBytes()
			local trim = buffer.create(offset + totalBytes)
			buffer.copy(trim, totalBytes, buf, 0, offset)
			if minimumBytes > 0 then
				writeBits(trim, 0, 0, minimumBytes, false)
			end
			if variableBytes > 0 then
				writeBits(trim, minimumBytes, minimumBytes * 8, variableBytes, true)
			end
			return {
				buffer = trim,
				blobs = blobs,
			}
		else
			local trim = buffer.create(offset)
			buffer.copy(trim, 0, buf, 0, offset)
			return {
				buffer = trim,
				blobs = blobs,
			}
		end
	end
end
return {
	createSerializer = createSerializer,
}
